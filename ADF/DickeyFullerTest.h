/**
 * @file
 * @author william
 *
 * Copyright 2011 Shooting Soul, LLC. and William DeMeo  All rights reserved.
 */

#ifndef DICKEYFULLERTEST_H_
#define DICKEYFULLERTEST_H_
#include "Regression.h"

namespace ttm {


/** class DickeyFullerTest  Tests whether a unit root is present in an autoregressive m_model.
 *
 * ----------- DICKEY-FULLER TEST ----------------
 *
 * The simplest case is to assume the data are generated by an MODEL_AR(1) process.  That is,
 * \[
 *        y_t = \rho y_{t-1} + u_t
 * \]
 * where y_t is the variable of interest, t is the time index, \rho is a coefficient, and u_t is the error term.
 * A unit root is present if \rho = 1. The m_model would be non-stationary in this case.
 *
 * The regression m_model can be written as
 * \[
 *       \Delta y_t = (\rho - 1) y_{t-1} +  u_t = \gamma y_{t-1} +  u_t
 * \]
 * where \Delta is the first difference operator. Testing for a unit root is equivalent to testing \gamma = 0
 * Since the test is done over the (estimated) residual term rather than raw data, it is not possible to use
 * standard t-m_distribution for critical values. This statistic has a special m_distribution, and critical values
 * are found in the Dickey–Fuller table.
 *
 * There are three main versions of the test:
 * 1. Test for a unit root:
 *    \[
  *           \Delta y_t = \gamma y_{t-1} +  u_t
 *    \]
  * 2. Test for a unit root with drift:
 *    \[
 *            \Delta y_t = a + \gamma y_{t-1} +  u_t
 *    \]
 * 3. Test for a unit root with drift and deterministic time trend:
 *    \[
 *            \Delta y_t = a + b t + \gamma y_{t-1} +  u_t
 *    \]
 *
 * Each version of the test has its own critical value which depends on the size of the sample.
 *
 * -------------  AUGMENTED DICKEY-FULLER TEST --------------
 *
 * The testing procedure for the ADF test is the same as for the Dickey–Fuller test but it is applied to the m_model
 * \[
 *        \Delta y_t = \m_alpha + \beta t + \gamma y_{t-1} + \detal_1 \Delta y_{t-1} + \cdots + \detal_{p-1} \Delta y_{t-p+1} + \epsilon_t
 * \]
 * where \m_alpha is a constant, \beta the coefficient on a time trend and p the lag order of the autoregressive process.
 * Imposing the constraints \m_alpha = 0 and \beta = 0 corresponds to modeling a random walk, and using the constraint
 * \beta = 0 corresponds to modeling a random walk with a drift.
 *
 * The unit root test is then carried out under the null hypothesis \gamma = 0 against the alternative hypothesis of
 * \gamma < 0. To run the test, we use Regression to find an estimate \hat{\gamma} of \gamma, then compute the test statistic
 * T = \hat{\gamma}/m_se(\hat{\gamma}), and then compare T to the relevant critical value for the Dickey–Fuller Test.
 * If the test statistic is less than the critical value, then the null hypothesis of \gamma = 0 is rejected and
 * no unit root is present. (this test is non symmetrical so we do not consider an absolute value)
 *
 * @see http://en.wikipedia.org/wiki/Dickey%E2%80%93Fuller_test
 *
 */
class DickeyFullerTest {
public:

	/** @param model_type  Specifies which model to use as the null hypothesis.
	 *
	 * TODO(wjd): add more m_model types. In particular, we should implement the augmented DF test... SOON!
	 * So far, we only have two simple models available:
	 *
	 *     MODEL_AR  <--> basic MODEL_AR(1) test for unit root:       DY_t =     b Y_{t-1} + u_t
	 *     MODEL_ARD <--> MODEL_AR(1) test for unit root with drift:  DY_t = a + b Y_{t-1} + u_t
	 *
	 * We should improve this, and code up the so-called "augmented Dickey-Fuller test" which accommodates
	 * MODEL_AR(p) models with and without drift and/or trend.
	 */
	enum model_type { MODEL_AR, MODEL_ARD };

	static const string MODEL_NAME[]; //!< model names

	DickeyFullerTest(size_t N, double* y);
	DickeyFullerTest(size_t N, double* y, model_type m, size_t l, double a);

	virtual ~DickeyFullerTest();

	void set_model(model_type m) { 	m_model = m; }

	void set_lags(size_t l) {	m_lags = l;  }

	void copy_first_differences(double* diffy) const;

	/** test a vector of time-series data for a unit root (non-stationarity). */
	void run_test();

	int get_test_H() const { return m_test_H; }
	double get_p_value() const { return m_p_value; }
	double get_c_value() const { return m_c_value; }
	double get_test_statistic() const { return m_test_statistic; }
	double get_reg_coef(size_t i) const { return m_reg->get_coef(i) + 1; } // N.B. ADD 1!!!
	double get_reg_se(size_t i) const { return m_reg->get_se(i); }
	double get_reg_mse() const { return m_reg->get_mse(); }
	size_t get_effective_sample_size() const { return m_effective_sample_size; }
	size_t get_CV_sample_size() const {return m_CV_sample_size; }
	double get_sig_level() const { return m_sig_level; }

	/** display the results of the regression used in the test */
	void display_regression_results(ostream *out=&std::cout) const;

	/** check that member variables required for conducting the test have been initialized */
	void check_initial_member_variables() const;

	/** display the initial set-up parameters of the test */
	void display_attributes(ostream *out=&std::cout) const;

	/** check that all member variables have been initialized */
	void check_all_member_variables() const;

	/** display the results of the test */
	void display_results(ostream *out=&std::cout) const;

private:

	/** @param m_length  Length of the data array m_y.  */
	size_t m_length;

	/** @param m_y  The 1-d array of data to be tested for unit-root non-stationarity. */
	double* m_y;

	/** @param m_diffy  The first differences of the series m_y. */
	double* m_diffy;

	/** @param m_model  Specifies which m_model represents the null hypothesis of the test
	 * TODO(wjd): add more m_model types. In particular, we should implement the augmented DF test... SOON! */
	model_type m_model;

	/** @param m_lags   The number of m_lags (regressors) to use.  For MODEL_AR(1), m_lags=1          */
	size_t m_lags;

	/** @param m_effective_sample_size  The effective sample size.  It is m_length minus the number of m_lags
	 *                       used as regressor terms.  For the simple MODEL_AR(1) m_model it's just m_length-1.  */
	size_t m_effective_sample_size;

	/** @param m_CV_sample_size  The sample size closest to (no smaller than) m_effective_sample_size of the
	 *                          list of sample sizes represented in our table of critical values. */
	size_t m_CV_sample_size;

	/** @param m_alpha  Specifies the level of significance at which to test the null hypothesis.
	 *                  (Theoretically, this can be any real number in the open interval (0.0, 1.0).
	 *                  However, it's usually one of the numbers {0.025, 0.30, ..., 0.10},
	 *                  (a subset of the numbers in the static array DFTest_sigLevel). */
	double m_alpha;

	/** @param m_sig_level  The significance level in sigLevel[] that is closest to (no bigger than) m_alpha */
	double m_sig_level;

	/** @param m_test_H  The result of the test.
	 *                   0 means fail to reject null hypothesis of a unit root.
	 *                   1 means reject null hypothesis in favor of the alternative (no unit root). */
	int m_test_H;

	/** @param m_p_value Probability of observing the computed test statistic under the null hypothesis.
	 *                  If this is less than m_alpha, we reject the null and set m_test_H = 1.  */
	double m_p_value;

	/** @param m_c_value The critical value is the number in table of critical values that corresponds to
	 *                   significance level m_alpha. */
	double m_c_value;

	/** @param m_reg    Estimated regression m_model of the form that is assumed to hold under
	 *                  the null hypothesis.  */
	Regression *m_reg;

	/** @param m_test_statistic  For the simple Dickey-Fuller test, this is
	 * 	                        (beta - 1)/SE(beta)
	 *                          where beta is the coefficient of y_{t-1} in the MODEL_AR m_model.
	 *  */
	double m_test_statistic;

	void compute_test_statistic();


	bool compute_p_value(const double* table);

	/* DFTest_CVTables
	 These are 1-d arrays which represent 15 x 50 matrices, where each row stores the critical values
	 of a certain Dickey-Fuller test for a given sample size.  The corresponding sample sizes are stored
	 in the 15 element array called DFTest_CVSampleSize.  The columns correspond to the significance
	 levels given in the array DFTest_sigLevel.

	 N.m_B. Different tables are used, depending on the m_model assumption, as specified by the
	 variable model_type.
	 */
	static const double CVTable_AR[];
	static const double CVTable_ARD[];

	static const double sigLevel[];
	static const int sigLevelLength;

	/** get index of the element in DFTest_sigLevel array that is the greatest value not above alpha.
	 * @param alpha  (Max) significance level at which test should be performed.
	 * @param i      The index such that DFTest_sigLevel[i] is the greatest sigLevel that is no greater than alpha.
	 *               This is the significance level at which we will perform the test.
	 *               So, i is the column of the CVTable we will use.	 */
	int get_sig_index(const double& alpha, int& i);

	static const int CVSampleSize[];
	static const int CVSampleSizeLength;
	// get_sample_size_index() -- get index of element in DFTest_CVsampleSize array that is the greatest value not above sampleSize.
	int get_sample_size_index(const int& sampleSize, int &i);

	static const int CVTableNumCols;   // == sigLevelLength;
	static const int CVTableNumRows;   // == CVSampleSizeLength;
	static const int CVTableLength;    // == CVTableNumCols* CVTableNumRows;



};

}

#endif /* DICKEYFULLERTEST_H_ */
